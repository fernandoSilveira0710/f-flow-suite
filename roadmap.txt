# F-Flow Suite — Roadmap de Entrega (MVP ➜ SaaS)

> **Regra de ouro:** cada etapa fecha com **critérios de aceite**, **flag de segurança** e **rollback** simples. Só avançamos quando a etapa anterior estiver verde em PR.

## Status Atual — Concluídos e Pendências

### Concluídos (✅)
- ✅ Etapa 1 — Setup de DEV e Padrões de Projeto
- ✅ Etapa 2 — Hub: Banco + RLS + JWKS
- ✅ Etapa 3 — Client-Local Executável (DB embutido + Serviço SO)
- ✅ Etapa 4 — Licenciamento ponta-a-ponta (Ativar, Guardar, Renovar)
- ✅ Etapa 5 — Autenticação OIDC real + Dupla Validação no Hub
- ✅ Etapas 6.8, 6.9 e 6.10 — Configurações/Dashboard, Integração & Saúde, Documentação & Flags
- ✅ Etapa 10 — Site Institucional + Postman E2E + Releases/Auto-update

### Pendências
- Etapa 1: fechar "Lint e typecheck OK" nos 3 pacotes (corrigir pequenos erros de TypeScript no Hub)
- Etapa 6 — POS/Inventory MVP + Espelho básico no Hub:
  - 6.1 Modelagem e Migrations: revisar entidades e aplicar RLS nas novas tabelas
  - 6.2 CRUD de Produtos e Estoque: endpoints, ajustes de estoque e eventos `event.product.*`
    - ✅ Hub: `EventsService.createEvent` unificado para produtos (Outbox normalizado)
    - ✅ Hub: modelo `InventoryAdjustment` criado e migrado
    - ⏳ Client-local: endpoints e ajuste de estoque
  - 6.3 CRUD de Vendas/PDV: endpoints, cálculo de totais e evento `event.sale.created.v1`
    - ✅ Hub: emissão de eventos `sale.created.v1` e `sale.updated.v1` após create/update
    - ⏳ Client-local: cálculo automático de totais e endpoints completos
  - 6.4 Clientes (Tutores) e Pets: CRUD e eventos `event.customer.*` e `event.pet.*`
  - 6.5 Serviços e Profissionais: CRUD e eventos de sync
  - 6.6 Agenda, Check‑in e Recursos: CRUD, check‑in/out e eventos `event.appointment.*` e `event.checkin.*`
    - ✅ Hub: geração de eventos padronizada via `EventsService.createEvent` (appointments, check-ins e resources)
  - 6.7 Grooming (Banho e tosa): tickets, itens, status e espelho no Hub
- Etapa 7 — Sync Agent (Outbox/Inbox, Idempotência, Backoff, DLQ): implementar Outbox/Inboux, scheduler, schemas versionados e DLQ
- Etapa 8 — Pagamentos Mínimo Viável + Conciliação: módulo `payments`, conciliação no Hub e validação de schemas
- Etapa 9 — Frontend Integrado ao Client-Local + Status de Sync: trocar mocks por client-local, UI de status e integração CRUD via React Query

## Etapa 1 — Setup de DEV e Padrões de Projeto ✅

**Objetivo:** time ligar o projeto em 1 comando e alinhar padrões (lint, testes, branch/PR).
**Escopo**

* ✅ Adicionar `docker-compose.yml` (apenas DEV) com `postgres + adminer + hub`.
* ✅ Criar `hub/.env.example` e `client-local/.env.example`.
* ✅ Scripts `npm run dev:up` / `dev:down` (ou `make`).
* ✅ Padronizar ESLint/Prettier/EditorConfig nos 3 pacotes.
* ✅ Definir convenções: `feat/`, `fix/`, `chore/`, `docs/` + PR template.
  **Flags**
* ✅ `DEV_COMPOSE_ENABLED=true` (apenas dev).
  **Aceite**
* ✅ `docker compose up -d` sobe Hub + DB e `GET /health` OK.
* ⚠️ Lint e typecheck OK nos 3 pacotes (pequenos erros de TypeScript no Hub).
  **Rollback**
* ✅ Remover compose e `.env` se der ruim (não afeta prod).

---

## Etapa 2 — Hub: Banco + RLS + JWKS ✅

**Objetivo:** segurança por tenant e chave pública para licença.
**Escopo**

* ✅ Rodar migrations Prisma do Hub; aplicar `sql/002-rls-policies.sql`.
* ✅ Middleware global exigindo `x-tenant-id` (ou derivado do usuário).
* ✅ Expor `GET /.well-known/jwks.json` com a key pública (RS256).
* ✅ Tests de integração: dois tenants isolados (0 vazamento).
  **Flags**
* ✅ `RLS_ENFORCED=true`.
  **Aceite**
* ✅ Sem `x-tenant-id` → 403; com tenant errado → 200 + **0 linhas**.
* ✅ `/.well-known/jwks.json` servindo JWKS válido.
  **Rollback**
* ✅ Desligar `RLS_ENFORCED` (só DEV) até corrigir.

---

## Etapa 3 — Client-Local Executável (DB embutido + Serviço SO) ✅

**Objetivo:** cliente clica e usa. Binário único sobe server e DB local.
**Escopo**

* ✅ Empacotar `client-local` com **pkg**/**nexe** (Win/Mac/Linux).
* ✅ Bootstrap: resolve pastas por SO → roda migrations → sobe HTTP `127.0.0.1:8081`.
* ✅ Serviço do SO: Windows Service / launchd / systemd (scripts básicos).
* ✅ Logs estruturados (JSON) com rotação.
  **Flags**
* ✅ `LOCAL_SERVER_ENABLED=true`.
  **Aceite**
* ✅ Primeira execução cria DB e responde `GET /health`.
* ✅ Serviço inicializa com o sistema (Windows validado).
  **Rollback**
* ✅ Parar serviço e usar `npm run start:dev` (DEV only).

---

## Etapa 4 — Licenciamento ponta-a-ponta (Ativar, Guardar, Renovar) ✅

**Objetivo:** ativar licença com o Hub, validar RS256 e operar offline com grace.
**Escopo**

* ✅ Hub: `POST /licenses/activate` assina **JWT RS256** com `LICENSE_PRIVATE_KEY_PEM`.
* ✅ Client-local: `POST /licensing/activate` (usado pelo front), guarda token no **DPAPI/Keychain/Keyring**, agenda **renovação** automática.
* ✅ `GET /install/status` para o front saber se precisa de setup.
* ✅ Política **offline grace** (ex.: 7 dias).
* ✅ `LicensingGuard` implementado para proteger rotas de negócio.
* ✅ Testes unitários e e2e implementados.
* ✅ Documentação completa no README.md.
* ✅ **Sistema de Planos Integrado**: Frontend ERP com painel de billing completo.
* ✅ **Sincronização de Planos**: Client-local sincroniza mudanças de plano com Hub.
* ✅ **Validação SQLite**: Sistema totalmente funcional com banco SQLite local.
* ✅ **Entitlements Dinâmicos**: Recursos habilitados/desabilitados baseados no plano ativo.
  **Flags**
* ✅ `LICENSING_ENFORCED=true` (em dev pode ser false).
  **Aceite**
* ✅ Wizard de ativação funciona; serviço reinicia offline e continua dentro do grace.
* ✅ Sistema suporta modo desenvolvimento e produção.
* ✅ Endpoints `/licensing/activate`, `/licensing/install/status`, `/licensing/license` funcionais.
* ✅ Verificação JWT RS256 com chave pública.
* ✅ Armazenamento seguro de tokens.
* ✅ Renovação automática de licenças.
* ✅ **Painel de Billing**: Interface completa em `/erp/settings/billing` com planos, histórico e upgrade.
* ✅ **Sincronização de Planos**: Mudanças de plano refletem imediatamente no sistema.
* ✅ **Teste de Integração**: Sistema validado com SQLite, Hub e Client-local funcionando em conjunto.
  **Rollback**
* ✅ Setar `LICENSING_ENFORCED=false` (DEV) enquanto corrige.

**Como testar:**
1. **Preparação**: 
   ```bash
   cd client-local
   npm install
   cp .env.example .env
   ```
2. **Modo Desenvolvimento**: 
   ```bash
   # Editar .env: LICENSING_ENFORCED=false
   npm run start:dev
   ```
3. **Ativação Manual**: 
   ```bash
curl -X POST http://localhost:8081/licensing/activate \
     -H "Content-Type: application/json" \
     -d '{"tenantId": "test-tenant", "deviceId": "test-device"}'
   ```
4. **Verificar Status**: `curl http://localhost:8081/licensing/install/status`
5. **Modo Offline**: Desconectar rede e verificar grace period
6. **Testes**: `npm test` e `npm run test:e2e`

## Instruções de Teste do Sistema de Licenciamento

### 1. Preparação
```bash
cd client-local
npm install
cp .env.example .env
```

### 2. Configuração para Desenvolvimento
```bash
# Editar .env:
LICENSING_ENFORCED=false
```

### 3. Iniciar o Serviço
```bash
npm run start:dev
```

### 4. Testar Endpoints (PowerShell)✅
```powershell
# Status da instalação
Invoke-RestMethod -Uri "http://localhost:8081/licensing/install/status" -Method GET

# Ativação manual
Invoke-RestMethod -Uri "http://localhost:8081/licensing/activate" -Method POST -ContentType "application/json" -Body '{"tenantId": "test-tenant", "deviceId": "test-device"}'

# Verificar licença
Invoke-RestMethod -Uri "http://localhost:8081/licensing/license" -Method GET
```

### 5. Verificar Status
- Status: `development`
- Plan: `development` 
- NeedsSetup: `false`

### 6. Testar Modo Offline
1. Ativar licença válida
2. Desconectar internet
3. Reiniciar serviço
4. Verificar funcionamento (grace period: 7 dias)

### 7. Executar Testes
```bash
# Unitários (alguns falham em modo dev)
npm test

# E2E
npm run test:e2e

# Cobertura
npm run test:cov
```

### 8. Resultados Esperados

**Status (Dev Mode):**
```json
{
  "needsSetup": false,
  "status": "development",
  "plan": "development"
}
```

**Ativação (Dev Mode):**
```json
{
  "status": "activated",
  "message": "Licensing not enforced in development mode"
}
```

**Licença (Dev Mode):**
```json
{
  "tid": "dev-tenant",
  "did": "00000000-0000-0000-0000-000000000000",
  "plan": "enterprise",
  "ent": ["POS", "INVENTORY", "GROOMING", "ANALYTICS"],
  "exp": 1759582419,
  "grace": 7,
  "iat": 1759496019,
  "iss": "dev-mode",
  "status": "development"
}
```

---

## Etapa 5 — Autenticação OIDC real + Dupla Validação no Hub ✅

**Objetivo:** proteger Hub com IdP (Auth0/Keycloak/Cognito) **e** validar licença própria.
**Escopo**

* Guard OIDC no Hub (`aud/iss/exp` via JWKS do IdP).
* License Guard nas rotas sensíveis (valida JWT de licença do cliente).
* Variáveis `.env`: `OIDC_JWKS_URL`, `OIDC_AUDIENCE`, `OIDC_ISSUER`.
  **Flags**
* `OIDC_REQUIRED=true` (em dev pode ser false pra smoke).
  **Aceite**
* Sem OIDC → 401; com OIDC e sem licença → 403; com ambos → 200.
  **Rollback**
* `OIDC_REQUIRED=false` e/ou bypass licenças **só em DEV**.

---

## Etapa 6 — POS/Inventory MVP no Client-Local + Espelho básico no Hub

**Objetivo:** rodar o fluxo core no executável (sem quebrar nada) e preparar espelho no Hub.
**Escopo**

* Client-local: CRUD **Produtos**, **Estoque**, **Vendas** com Prisma.
* Eventos locais mínimos: `event.product.upserted.v1`, `event.sale.created.v1`.
* Hub: endpoints de ingest ou leitura para espelhamento por tenant (simples).
* Health de dependências: DB local OK e Hub reachable (quando online).
  **Flags**
* `MVP_POS_ENABLED=true`.
  **Aceite**
* CRUD local persistindo no SQLite/SQLCipher e APIs respondendo 200.
* Schemas JSON validados por Ajv localmente.
  **Rollback**
* `MVP_POS_ENABLED=false` volta ao estado anterior.

Modelagem e Migrations (6.1)

Definir todas as entidades no schema Prisma do client‑local e do Hub. Exemplos de modelos:

Product: id, tenantId, sku, name, description, salePrice, costPrice, stockQty, createdAt, updatedAt;

Sale / SaleItem: id, tenantId, code, date, operator, total, paymentMethod, createdAt, updatedAt; itens: productId, qty, unitPrice;

InventoryAdjustment: id, tenantId, productId, delta, reason, createdAt;

Customer (Tutor): id, tenantId, name, phone, email, createdAt, updatedAt;

Pet: id, tenantId, tutorId, name, species, breed, weight, birthDate, createdAt, updatedAt;

Service: id, tenantId, name, description, price, duration, createdAt, updatedAt;

Professional: id, tenantId, name, role, createdAt, updatedAt;

Appointment (Agenda): id, tenantId, petId, serviceId, professionalId, date, startTime, endTime, status, createdAt;

GroomingTicket / GroomingItem: id, tenantId, petId, tutorId, status, createdAt; itens: serviceId, name, price, qty;

Resource: id, tenantId, name, type, createdAt;

CheckIn: id, tenantId, petId, professionalId, checkInAt, checkOutAt, notes;

Configuration: key, value, tenantId; etc.

Atualizar migrations no Hub e no client-local. Adicionar políticas RLS para as novas tabelas.

CRUD de Produtos e Estoque (6.2)

Client-local: criar módulo product com controller/DTO/service usando Prisma; endpoints: GET/POST/PATCH/DELETE em /products. Idêntico para inventory: endpoint para ajustar estoque (POST /inventory/adjust) e obter níveis atuais (GET /inventory/:productId). Persistir em SQLite/SQLCipher.

Eventos: gerar event.product.upserted.v1 e event.product.deleted.v1 e armazenar em OutboxEvent.

Hub: criar endpoints de leitura (GET /tenants/:tenantId/products) e ingestão via SyncService para aplicar eventos.

CRUD de Vendas/PDV (6.3)

Client-local: módulo sales com endpoints POST /sales, GET /sales, GET /sales/:id. Salvar vendas e itens na base. Calcular total, registrar método de pagamento.

Gerar event.sale.created.v1 com itens e pagamento.

Hub: endpoint de leitura /tenants/:tenantId/sales e ingestão de vendas via sync.

Clientes (Tutores) e Pets (6.4)

CRUD completo para Customer e Pet no client-local. Ligação tutor→pet.

Eventos event.customer.upserted.v1, event.pet.upserted.v1.

Espelho no Hub para relatórios e sincronização.

Serviços e Profissionais (6.5)

CRUD de Service (grooming, banho, consulta etc.) e Professional (veterinários, groomers) no client-local.

Eventos correspondentes para sync. Hub espelha.

Agenda, Check‑in e Recursos (6.6)

CRUD de Appointment com validação de choques de agenda.

Endpoint para check‑in/check‑out de pets (POST /checkin, POST /checkout) e armazenamento em CheckIn.

CRUD de Resource e vinculação aos agendamentos se necessário (sala, mesa).

Eventos event.appointment.created.v1, event.checkin.created.v1, etc.

Grooming (Banho e tosa) (6.7)

Completar módulo grooming: endpoints para abrir ticket, adicionar itens, atualizar status. Persistir ticket e itens.

Gerar event.grooming.ticket.created.v1 e event.grooming.ticket.updated.v1.

Hub espelha para relatórios.

Configurações e Dashboard (6.8) ✅ CONCLUÍDO

✅ CRUD simples para configurações da loja: métodos de pagamento, impostos, temas, etc.

✅ Endpoint /dashboard/summary que retorna métricas (total de vendas, estoque baixo, agendas do dia).

Criar queries no Hub para relatórios agregados.

Integração e Saúde (6.9) ✅ CONCLUÍDO

✅ Atualizar o SyncAgent para lidar com todos os novos eventos, com schemas JSON validados por Ajv.

✅ Ajustar sync.service.ts no Hub para aplicar eventos a cada tabela.

✅ Melhorar /health/deps no client-local para checar SQLite e pingar Hub.

Documentação e Flags (6.10) ✅ CONCLUÍDO

✅ Atualizar .env.example adicionando MVP_POS_ENABLED, MVP_GROOMING_ENABLED, etc., caso deseje ativar módulos individualmente.

✅ Implementar sistema de feature flags com endpoints REST (/feature-flags).

Atualizar README e Roadmap.

Atualizar coleção Postman: novos grupos para Produtos, Estoque, Vendas, Clientes, Pets, Serviços, Profissionais, Agenda, Grooming, Configurações, Dashboard.

📌 Observações finais

Nenhum mock: todas as operações devem persistir em banco e gerar eventos.

Ajv validation: defina esquemas JSON para cada evento e valide no client-local antes de registrar no outbox.

Hub RLS: adicione políticas para novas tabelas com tenant_id usando SET app.tenant_id (já implementado).

Incremental PRs: cada sub-etapa pode ser submetida em um PR, garantindo que testes passem e que a base não quebre.

---

## Etapa 7 — Sync Agent (Outbox/Inbox, Idempotência, Backoff, DLQ)

**Objetivo:** sincronização automática, tolerante a falhas, invisível ao usuário.
**Escopo**

* **Outbox**: fila local com `PENDING/SENT/ACKED`, `retry_at`, **backoff exponencial**, **DLQ**.
* **Inbox**: aplicação de **comandos versionados** do Hub com **idempotência** (`commandId`).
* Schemas versionados em `client-local/src/sync/schemas/*`.
* Scheduler interno (cron) gerenciando sync/renovação.
  **Flags**
* `SYNC_ENABLED=true` (padrão off até fechar testes).
  **Aceite**
* Sem internet: eventos acumulam; com internet: flush sem duplicar.
* Logs mostram reprocesso e DLQ quando extrapola tentativas.
  **Rollback**
* `SYNC_ENABLED=false` deixa tudo local até ajustar.

---

## Etapa 8 — Pagamentos Mínimo Viável + Conciliação Simples

**Objetivo:** registrar pagamentos (dinheiro, débito, crédito) e espelhar no Hub.
**Escopo**

* Client-local: módulo `payments` vinculado à venda.
* Estender `event.sale.created.v1` com `payments[]`.
* Hub: ingest/armazenamento para relatórios.
  **Flags**
* `PAYMENTS_ENABLED=true`.
  **Aceite**
* Vendas com pagamentos persistem local e sincronizam ao Hub quando online.
* Hub rejeita payload inválido com erro claro (schema).
  **Rollback**
* `PAYMENTS_ENABLED=false` para operar sem pagamentos (somente registro de venda).

---

## Etapa 9 — Frontend Integrado ao Client-Local + Status de Sync

**Objetivo:** trocar mocks por client-local e expor status na UI sem travar o uso.
**Escopo**

* `web`: `VITE_API_BASE=http://127.0.0.1:8081`.
* Rota `/setup`: usa `GET /install/status` e `POST /licensing/activate`.
* Integrar CRUDs do **POS/Inventory** via **React Query**.
* Banner/Badge de status: **Online/Offline/Syncing**.
* Loading/empty states decentes (sem UX travada).
  **Flags**
* `USE_LOCAL_API=true` (em dev dá pra forçar mock com `false`).
  **Aceite**
* Usuário final opera 100% via executável + UI; sem internet o sistema funciona (grace + local), com internet sincroniza.
  **Rollback**
* `USE_LOCAL_API=false` volta pro mock (apenas DEV).

---

## Etapa 10 — Site Institucional + Postman E2E + Releases/Auto-update ✅

**Objetivo:** pacote completo para distribuir o SaaS.
**Escopo**

* ✅ **Site institucional** (landing + docs de instalação) no monorepo (`/site`), build estático (Vite/Next estático).
* ✅ **Coleção Postman** E2E: seed → health → ativar licença → CRUD → sync roundtrip.
* ✅ **Auto-update** do client-local:

  * ✅ Serviço verifica versão publicada (GitHub Releases/S3).
  * ✅ Download silencioso + aplicação + rollback se health falhar.
* ✅ **CI/CD (GitHub Actions)**:

  * ✅ Lint, typecheck, unit, integração (Hub com Postgres de serviço).
  * ✅ Build **binários** + **instaladores** (NSIS/pkgbuild/deb).
  * ✅ Publica em **Releases** com changelog.
    **Flags**
* ✅ `AUTO_UPDATE_ENABLED=true` (produção).
  **Aceite**
* ✅ Instalação fresca: setup de licença → uso normal → sync OK.
* ✅ Update publicado ➜ cliente atualiza sozinho e mantém dados/serviço.
  **Rollback**
* ✅ Pipeline mantém **artefato anterior**; auto-update reverte quando health falha.

---

## Convenções Gerais (valem em todas as etapas)

* **Feature flags** via `.env` com defaults seguros; em produção tudo que não está pronto fica **OFF**.
* **Testes**: unit + integração onde mexer; E2E via Postman na Etapa 10.
* **Observabilidade** (ligar gradualmente): `/health`, `/health/deps`, logs JSON com `requestId`, `tenantId`, `deviceId`. Métricas no Hub (Prometheus).
* **Segurança**: nunca logar segredos. Tokens/keys sempre em keystore do SO.
* **Branches/PRs**:

  * Um PR por etapa (ou sub-etapa). Nome: `feat/etapa-X-*`.
  * Checklist no PR com critérios de aceite.
  * Sem squash de features em PRs gigantes; preferir incrementos pequenos.

---

## Ordem de Merge (resumo)

1. **Etapa 1** ➜ 2 ➜ 3 ➜ 4 ➜ 5 (fundação de segurança)
2. **Etapa 6** (POS local)
3. **Etapa 7** (Sync robusto)
4. **Etapa 8** (Pagamentos)
5. **Etapa 9** (Front integrado)
6. **Etapa 10** (Site + E2E + Releases/Auto-update)
